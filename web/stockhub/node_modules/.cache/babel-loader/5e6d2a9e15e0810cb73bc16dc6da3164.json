{"ast":null,"code":"var _slicedToArray = require(\"/Users/lilybhattacharjee/Documents/stockhub/web/stockhub/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst _require = require('stream'),\n      Transform = _require.Transform;\n\nconst genobj = require('generate-object-property');\n\nconst genfun = require('generate-function');\n\nconst bufferFrom = require('buffer-from');\n\nconst bufferAlloc = require('buffer-alloc');\n\nconst _bufferFrom = bufferFrom('\\r'),\n      _bufferFrom2 = _slicedToArray(_bufferFrom, 1),\n      cr = _bufferFrom2[0];\n\nconst _bufferFrom3 = bufferFrom('\\n'),\n      _bufferFrom4 = _slicedToArray(_bufferFrom3, 1),\n      nl = _bufferFrom4[0];\n\nconst defaults = {\n  escape: '\"',\n  headers: null,\n  mapHeaders: ({\n    header\n  }) => header,\n  mapValues: ({\n    value\n  }) => value,\n  newline: '\\n',\n  quote: '\"',\n  raw: false,\n  separator: ',',\n  skipComments: false,\n  skipLines: null,\n  maxRowBytes: Number.MAX_SAFE_INTEGER,\n  strict: false\n};\n\nclass CsvParser extends Transform {\n  constructor(opts = {}) {\n    super({\n      objectMode: true,\n      highWaterMark: 16\n    });\n    if (Array.isArray(opts)) opts = {\n      headers: opts\n    };\n    const options = Object.assign({}, defaults, opts);\n    this.customNewline = options.newline !== defaults.newline;\n\n    for (const key of Object.keys(options)) {\n      if (['newline', 'quote', 'separator'].includes(key)) {\n        var _bufferFrom5 = bufferFrom(options[key]);\n\n        var _bufferFrom6 = _slicedToArray(_bufferFrom5, 1);\n\n        options[key] = _bufferFrom6[0];\n      } // legacy codebase support\n\n\n      this[key] = options[key];\n    } // if escape is not defined on the passed options, use the end value of quote\n\n\n    this.escape = (opts || {}).escape ? bufferFrom(options.escape)[0] : options.quote;\n\n    if (this.headers === false) {\n      // enforce, as the column length check will fail if headers:false\n      this.strict = false;\n    }\n\n    this._prev = null;\n    this._prevEnd = 0;\n    this._first = true;\n    this._quoted = false;\n    this._escaped = false;\n    this._empty = this._raw ? bufferAlloc(0) : '';\n    this._Row = null;\n    this._currentRowBytes = 0;\n    this._line = 0;\n\n    if (this.headers || this.headers === false) {\n      this._first = false;\n\n      this._compile();\n    }\n  }\n\n  _compile() {\n    if (this._Row) return;\n    const Row = genfun()('function Row (cells) {');\n\n    if (this.headers) {\n      this.headers.forEach((header, index) => {\n        const newHeader = this.mapHeaders({\n          header,\n          index\n        });\n\n        if (newHeader) {\n          Row('%s = cells[%d]', genobj('this', newHeader), index);\n        }\n      });\n    } else {\n      // -> false\n      Row(\"\\n        for (const [index, value] of cells.entries()) {\\n          this[index] = value\\n        }\\n      \");\n    }\n\n    Row('}');\n    this._Row = Row.toFunction();\n    Object.defineProperty(this._Row.prototype, 'headers', {\n      enumerable: false,\n      value: this.headers\n    });\n  }\n\n  _emit(Row, cells) {\n    this.push(new Row(cells));\n  }\n\n  _flush(cb) {\n    if (this._escaped || !this._prev) return cb();\n\n    this._online(this._prev, this._prevEnd, this._prev.length + 1); // plus since online -1s\n\n\n    cb();\n  }\n\n  _oncell(buf, start, end) {\n    // remove quotes from quoted cells\n    if (buf[start] === this.quote && buf[end - 1] === this.quote) {\n      start++;\n      end--;\n    }\n\n    let y = start;\n\n    for (let i = start; i < end; i++) {\n      // check for escape characters and skip them\n      if (buf[i] === this.escape && i + 1 < end && buf[i + 1] === this.quote) i++;\n      if (y !== i) buf[y] = buf[i];\n      y++;\n    }\n\n    const value = this._onvalue(buf, start, y);\n\n    return value;\n  }\n\n  _online(buf, start, end) {\n    end--; // trim newline\n\n    if (!this.customNewline && buf.length && buf[end - 1] === cr) end--;\n    const comma = this.separator;\n    const cells = [];\n    let isQuoted = false;\n    let offset = start;\n    const skipComments = this.skipComments;\n\n    if (skipComments) {\n      const char = typeof skipComments === 'string' ? skipComments : '#';\n\n      if (buf[start] === bufferFrom(char)[0]) {\n        return;\n      }\n    }\n\n    const mapValue = value => {\n      if (this._first) {\n        return value;\n      }\n\n      const index = cells.length;\n      const header = this.headers[index];\n      return this.mapValues({\n        header,\n        index,\n        value\n      });\n    };\n\n    for (let i = start; i < end; i++) {\n      const isStartingQuote = !isQuoted && buf[i] === this.quote;\n      const isEndingQuote = isQuoted && buf[i] === this.quote && i + 1 <= end && buf[i + 1] === comma;\n      const isEscape = isQuoted && buf[i] === this.escape && i + 1 < end && buf[i + 1] === this.quote;\n\n      if (isStartingQuote || isEndingQuote) {\n        isQuoted = !isQuoted;\n        continue;\n      } else if (isEscape) {\n        i++;\n        continue;\n      }\n\n      if (buf[i] === comma && !isQuoted) {\n        let value = this._oncell(buf, offset, i);\n\n        value = mapValue(value);\n        cells.push(value);\n        offset = i + 1;\n      }\n    }\n\n    if (offset < end) {\n      let value = this._oncell(buf, offset, end);\n\n      value = mapValue(value);\n      cells.push(value);\n    }\n\n    if (buf[end - 1] === comma) {\n      cells.push(mapValue(this._empty));\n    }\n\n    const skip = this.skipLines && this.skipLines > this._line;\n    this._line++;\n\n    if (this._first && !skip) {\n      this._first = false;\n      this.headers = cells;\n\n      this._compile(cells);\n\n      this.emit('headers', this.headers);\n      return;\n    }\n\n    if (this.strict && cells.length !== this.headers.length) {\n      const e = new RangeError('Row length does not match headers');\n      this.emit('error', e);\n    } else {\n      if (!skip) this._emit(this._Row, cells);\n    }\n  }\n\n  _onvalue(buf, start, end) {\n    if (this._raw) return buf.slice(start, end);\n    return buf.toString('utf-8', start, end);\n  }\n\n  _transform(data, enc, cb) {\n    if (typeof data === 'string') data = bufferFrom(data);\n    let start = 0;\n    let buf = data;\n\n    if (this._prev) {\n      start = this._prev.length;\n      buf = Buffer.concat([this._prev, data]);\n      this._prev = null;\n    }\n\n    const bufLen = buf.length;\n\n    for (let i = start; i < bufLen; i++) {\n      const chr = buf[i];\n      const nextChr = i + 1 < bufLen ? buf[i + 1] : null;\n      this._currentRowBytes++;\n\n      if (this._currentRowBytes > this.maxRowBytes) {\n        return cb(new Error('Row exceeds the maximum size'));\n      }\n\n      if (!this._escaped && chr === this.escape && nextChr === this.quote && i !== start) {\n        this._escaped = true;\n        continue;\n      } else if (chr === this.quote) {\n        if (this._escaped) {\n          this._escaped = false; // non-escaped quote (quoting the cell)\n        } else {\n          this._quoted = !this._quoted;\n        }\n\n        continue;\n      }\n\n      if (!this._quoted) {\n        if (this._first && !this.customNewline) {\n          if (chr === nl) {\n            this.newline = nl;\n          } else if (chr === cr) {\n            if (nextChr !== nl) {\n              this.newline = cr;\n            }\n          }\n        }\n\n        if (chr === this.newline) {\n          this._online(buf, this._prevEnd, i + 1);\n\n          this._prevEnd = i + 1;\n          this._currentRowBytes = 0;\n        }\n      }\n    }\n\n    if (this._prevEnd === bufLen) {\n      this._prevEnd = 0;\n      return cb();\n    }\n\n    if (bufLen - this._prevEnd < data.length) {\n      this._prev = data;\n      this._prevEnd -= bufLen - data.length;\n      return cb();\n    }\n\n    this._prev = buf;\n    cb();\n  }\n\n}\n\nmodule.exports = opts => new CsvParser(opts);","map":null,"metadata":{},"sourceType":"script"}